name: Flowzone

on:
  workflow_call:
    secrets:
      FLOWZONE_TOKEN:
        required: true
      NPM_TOKEN:
        required: true
      DOCKER_REGISTRY_USER:
        required: true
      DOCKER_REGISTRY_PASS:
        required: true
      BALENA_API_KEY_PUSH:
        required: true
      BALENA_API_KEY_TEST:
        required: false
      COMPOSE_VARS:
        required: false
    inputs:
      working_directory:
        description: 'Github actions working directory'
        type: string
        required: false
        default: '.'
      docker_images:
        description: 'Newline separated list of images (without tags) to push, default is no push'
        type: string
        required: false
      docker_cache_from:
        description: 'Newline separated list of additional external cache sources'
        type: string
        required: false
      docker_platforms:
        description: 'Newline separated list of target platforms, default is linux/amd64'
        type: string
        required: false
        default: 'linux/amd64'
      docker_context:
        description: 'Docker build context directory, default is ./'
        type: string
        required: false
      docker_file:
        description: 'Path to the Dockerfile relative to the context, default is ./Dockerfile'
        type: string
        required: false
      docker_target:
        description: 'Sets the target stage to build'
        type: string
        required: false

env:
  FLOWZONE_USER: 'balena-ci' # https://github.com/balena-ci

jobs:

  protect-branch:
    name: Protect branch
    runs-on: ubuntu-latest
    # only run on PR merges to the default branch and skip events triggered by flowzone
    if: ${{ github.event_name == 'push' && github.ref_name == github.event.repository.default_branch && !contains(github.event.head_commit.author.name, 'Flowzone') }}

    outputs:
      result: ${{ steps.protect_branch.outputs.result }}

    steps:

      - shell: bash
        id: protect_branch
        run: |
          url='${{ github.api_url }}/repos/${{ github.repository }}/branches/${{ github.event.repository.default_branch }}/protection'

          result="$(curl --silent -X PUT "${url}" \
            -H 'Accept: application/vnd.github+json' \
            -H 'Authorization: Bearer ${{ secrets.FLOWZONE_TOKEN }}' \
            -d '{
            "required_status_checks": {
              "strict": true,
              "contexts": [
                "Flowzone / Checks",
                "Flowzone / NPM",
                "Flowzone / Docker",
                "VersionBot/generate-version"
              ]
            },
            "enforce_admins": false,
            "required_pull_request_reviews": {
              "dismissal_restrictions": {
                "users": [],
                "teams": []
              },
              "dismiss_stale_reviews": false,
              "require_code_owner_reviews": false,
              "required_approving_review_count": 1,
              "bypass_pull_request_allowances": {
                "users": [],
                "teams": []
              }
            },
            "restrictions": null,
            "required_linear_history": false,
            "allow_force_pushes": false,
            "allow_deletions": false,
            "block_creations": false,
            "required_conversation_resolution": false
          }')"

          echo ::set-output name=result::"${result}"

  versionist:
    name: Versionist
    runs-on: ubuntu-latest
    # only run on PR merges to the default branch and skip events triggered by flowzone
    if: ${{ github.event_name == 'push' && github.ref_name == github.event.repository.default_branch && !contains(github.event.head_commit.author.name, 'Flowzone') }}

    outputs:
      version: ${{ steps.versionist.outputs.version }}

    steps:

      # checkout must happen in flowzone in order for local composite action path to exist
      - name: Checkout source
        uses: actions/checkout@v3
        with:
          # check out full depth for changelog generation
          fetch-depth: 0
          token: '${{ secrets.FLOWZONE_TOKEN }}'

      - name: Run Versionist
        id: versionist
        uses: ./.github/actions/versionist
        with:
          github_token: '${{ secrets.FLOWZONE_TOKEN }}'

  checks:
    name: Checks
    runs-on: 'ubuntu-latest'
    if: ${{ github.event_name == 'pull_request' && github.event.action != 'closed' && github.base_ref == github.event.repository.default_branch }}

    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
        shell: bash

    # Declare outputs for next jobs
    outputs:
      npm: ${{ steps.npm.outputs.enabled }}
      docker: ${{ steps.docker.outputs.enabled }}

    steps:

      - uses: actions/checkout@v2
        with:
          # Checkout as many commits as needed for the check
          fetch-depth: 1
          token: '${{ secrets.FLOWZONE_TOKEN }}'

      - id: npm
        run: |
          if test -f "package.json"; then
            echo "found package.json"
            echo ::set-output name=enabled::"True"
          else
            echo ::set-output name=enabled::"False"
          fi

      - id: docker
        run: |
          if [ -f docker-compose.test.yml ] && [ -f docker-compose.yml ]; then
            echo "found docker-compose.test.yml"
            echo ::set-output name=enabled::"True"
          else
            echo ::set-output name=enabled::"False"
          fi

  npm_flow:
    name: NPM
    runs-on: ubuntu-latest
    needs: [checks]
    if: needs.checks.outputs.npm == 'True'

    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
        shell: bash

    steps:

      - name: Checkout versioned source
        id: versionbot_checkout
        uses: actions/checkout@v3
        continue-on-error: true
        with:
          ref: 'versionbot/pr/${{ github.event.pull_request.number }}'
          fetch-depth: 1
          token: '${{ secrets.FLOWZONE_TOKEN }}'

      - name: Checkout original source
        if: ${{ steps.versionbot_checkout.outcome == 'failure' }}
        uses: actions/checkout@v3
        with:
          fetch-depth: 1
          token: '${{ secrets.FLOWZONE_TOKEN }}'

      - name: Run NPM flow
        uses: ./.github/actions/npm
        with:
          working_directory: ${{ inputs.working_directory }}
          node_version: '16.x'

  docker_flow:
    name: Docker
    runs-on: ubuntu-latest
    needs: [checks]
    if: needs.checks.outputs.docker == 'True'

    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
        shell: bash

    env:
      COMPOSE_VARS: ${{ secrets.COMPOSE_VARS }}
      LOCAL_IMAGE: localhost:5000/sut

    services:
      registry:
        image: registry:2.7.1
        ports:
          - 5000:5000

    steps:

      - name: Checkout versioned source
        id: versionbot_checkout
        uses: actions/checkout@v3
        continue-on-error: true
        with:
          ref: 'versionbot/pr/${{ github.event.pull_request.number }}'
          fetch-depth: 1
          token: '${{ secrets.FLOWZONE_TOKEN }}'

      - name: Checkout original source
        if: ${{ steps.versionbot_checkout.outcome == 'failure' }}
        uses: actions/checkout@v3
        with:
          fetch-depth: 1
          token: '${{ secrets.FLOWZONE_TOKEN }}'

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ env.FLOWZONE_USER }}
          password: ${{ secrets.FLOWZONE_TOKEN }}

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          registry: docker.io
          username: ${{ secrets.DOCKER_REGISTRY_USER }}
          password: ${{ secrets.DOCKER_REGISTRY_PASS }}

      - name: Run Docker flow
        uses: ./.github/actions/docker
        with:
          working_directory: ${{ inputs.working_directory }}
          images: ${{ inputs.docker_images }}
          cache_from: ${{ inputs.docker_cache_from }}
          platforms: ${{ inputs.docker_platforms }}
          context: ${{ inputs.docker_context }}
          dockerfile: ${{ inputs.docker_file }}
          target: ${{ inputs.docker_target }}
